<PROGRAM> ::= START <STMT>* END
<STMT> ::= <SIMPLE_STMT> | <COMPOUND_STMT>
<SIMPLE_STMT> ::= ( <ASSIGNMENT_STMT> | <RETURN_STMT> | <IO_STATEMENT> | <COLLECTION_STMT> | <DECL_STMT> ) SEMI
<COMPOUND_STMT> ::= <CONDITIONAL_STMT> | <LOOP_STMT> | <FUNC_DECL> | <CHOOSE_WHAT_STMT>

<EXPRESSION> ::= <TERM> | <EXPRESSION> <ADD_OP> <TERM>
<TERM> ::= <FACTOR> | <TERM> <MULTI_OP> <FACTOR>
<FACTOR> ::= <BASE> | <BASE> <EXP_OP> <FACTOR>
<BASE> ::= LPAREN <EXPRESSION> RPAREN | <CONST> | IDENTIFIER | <CONV_EXPR> | <COLLECTION_EXPR> | <COLLECTION_METHOD>
<CONST> ::= NUMBER | DECIMAL | QUOTE TEXT QUOTE | <BINARY> | NONE




<BIT_EXPR> ::= <BITOR_EXPR>
<BITOR_EXPR> ::= <BITXOR_EXPR> | <BITOR_EXPR> BITWISE_OR <BITXOR_EXPR>
<BITXOR_EXPR> ::= <BITAND_EXPR> | <BITXOR_EXPR> BITWISE_XOR <BITAND_EXPR>
<BITAND_EXPR> ::= <BITSHIFT_EXPR> | <BITAND_EXPR> BITWISE_AND <BITSHIFT_EXPR>
<BITSHIFT_EXPR> ::= <BITNOT_EXPR> | <BITSHIFT_EXPR> <SHIFT_OP> <BITNOT_EXPR>
<BITNOT_EXPR> ::= BITWISE_NOT <BIT_BASE>
<BIT_BASE> ::= LPAREN <BIT_EXPR> RPAREN | <EXPRESSION>




<DECL_STMT> ::= <DATA_TYPE> IDENTIFIER
<IO_STATEMENT> ::= <OUTPUT_STMT> | <INPUT_STMT>
<OUTPUT_STMT> ::= SHOW LPAREN <EXPRESSION> RPAREN
<INPUT_STMT> ::= GET <DATA_TYPE> <CONST> LPAREN RPAREN




<CONV_EXPR> ::= IDENTIFIER DOT CONVERTTO LPAREN <DATA_TYPE> RPAREN




<ASSIGNMENT_STMT> ::= IDENTIFIER <ASSIGN_OP> <EXPRESSION>
<RETURN_STMT> ::= OUTPUT <EXPRESSION>
<CONDITIONAL_STMT> ::= IF LPAREN <CONDITIONAL_EXPR> RPAREN <BLOCK_STMT> ( OTHERWISE <BLOCK_STMT>)*
<BLOCK_STMT> ::= RCURLY <STMT>* LCURLY




<CONDITIONAL_EXPR> ::= <LOGICOR_EXPR>
<LOGICOR_EXPR> ::= <LOGICAND_EXPR>  | <LOGICOR_EXPR> OR <LOGICAND_EXPR>
<LOGICAND_EXPR> ::= <LOGICNOT_EXPR> | <LOGICAND_EXPR> AND <LOGICNOT_EXPR>
<LOGICNOT_EXPR> ::= <RELATIONAL_EXPR> | NOT <LOGICNOT_EXPR>
<RELATIONAL_EXPR> ::= <EXPRESSION> <RELATIONAL_OP> <EXPRESSION> | LPAREN <CONDITIONAL_EXPR> RPAREN | <BINARY> | IDENTIFIER




<LOOP_STMT> ::= <FOR_LOOP> | <REPEAT_LOOP> | <REPEAT_UNTIL>
<FOR_LOOP> ::= FOR LPAREN <ASSIGNMENT_STMT> SEMI <CONDITIONAL_EXPR> SEMICOLON <EXPRESSION> RPAREN <BLOCK_STMT>
<REPEAT_LOOP> ::= REPEAT LPAREN <CONDITIONAL_EXPR> RPAREN <BLOCK_STMT>
<REPEAT_UNTIL> ::= REPEAT <BLOCK_STMT> UNTIL LPAREN <CONDITIONAL_EXPR> RPAREN




<FUNC_DECL> ::= METHOD IDENTIFIER LPAREN <PARAM_LIST>? RPAREN <BLOCK_STMT>
<PARAM_LIST> ::= IDENTIFIER (COMMA IDENTIFIER)*




<FUNC_CALL> ::= IDENTIFIER LPAREN <ARG_LIST>? RPAREN
<ARG_LIST> ::= <EXPRESSION> (COMMA <EXPRESSION>)*




<CHOOSE_WHAT_STMT> ::= CHOOSE_WHAT RCURLY <PICK_CASE>* LCURLY
<PICK_CASE> ::= PICK <EXPRESSION> COLON <BLOCK_STMT>




<COLLECTION_STMT> ::= <LIST_DECL> | <PAIR_MAP_DECL> | <COLLECTION_ASSIGN>
<LIST_DECL> ::= LIST_OF <DATA_TYPE> IDENTIFIER ASSIGN LBRACKET <EXPRESSION> (COMMA <EXPRESSION>)* RBRACKET
<PAIR_MAP_DECL> ::= PAIR_MAP LPAREN <DATA_TYPE> COLON <DATA_TYPE> RPAREN IDENTIFIER ASSIGN LBRACKET <PAIR_MAP_VAL> RBRACKET
<PAIR_MAP_VAL> ::= <PAIR> (COMMA <PAIR> )*
<PAIR> ::= LPAREN <EXPRESSION> COLON <EXPRESSION> RPAREN
<COLLECTION_ASSIGN> ::= <COLLECTION_EXPR> <ASSIGN_OP> <EXPRESSION>
<COLLECTION_EXPR> ::= <LIST_VALUE> | <PAIR_MAP_VALUE> | <PAIR_MAP_VALUE>
<LIST_VALUE> ::= IDENTIFIER LBRACKET <EXPRESSION> RBRACKET
<PAIR_MAP_VALUE> ::= IDENTIFIER DOT VALUE LBRACKET <EXPRESSION> RBRACKET
<PAIR_MAP_KEY> ::= IDENTIFIER DOT KEY LBRACKET <EXPRESSION> RBRACKET
<COLLECTION_METHOD> ::= IDENTIFIER DOT ( TOTEXT | LEN | SORT) LPAREN RPAREN




<DATA_TYPE> ::= BINARY_TYPE | NUMBER_TYPE | DECIMAL_TYPE | TEXT_TYPE | NONE
<RELATIONAL_OP> ::= EQ | NEQ | LT | GT | LEQ | GEQ
<ADD_OP> ::= PLUS | MINUS
<MULTI_OP> ::= MULT | DIV | MOD
<EXP_OP> ::= EXPONENT
<ASSIGN_OP> ::= ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MULT_ASSIGN
<SHIFT_OP> ::= LSHIFT | RSHIFT
<BINARY> ::= TRUE | FALSE